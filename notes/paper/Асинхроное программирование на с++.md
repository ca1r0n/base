epool, io_uring - библиотеки оптимизации работы с сокетами
libuv - библиотека для работы с callback'ами. Один из минусов это callback hell в виде лестници. 

# Feature и Promise

Feature - для получения данных
Promise - для отправки данных
В Js Promise имеет противоположную ценнтость, но суть остается прежней.  Так же в c++ есть встроенная реализация std::promise и std::feature. feature.get() блокирующая операция. Так же есть std::shared_feature для доступа с разных потоков и при вызове get() ошибки не произойдет.

# Переключение контекста в user space

библиотека ucontext

## Переключение контекста

Чтобы перенести контекст нужно:
1) Сохранить состояние (регистры из  calling convention, указатедь на кадр стека). Кадр стека это условно гдн лежать переменые функции.
2) Передвть управление на следуший контекст - востоновить сохранененое состояние.
![[Pasted image 20230708213551.png]]

Переключение контекста в user space намного дешевле чем переключение контекста OS treads.

Engine должен:
1) Хранить управляющий контекст
2) В успраляюшем контексте следить за поевлениями событий
3) Передавать управление в задачи, которые дождались futures
4) 
*Coroutine* - функции с несколькими точками входа/выхода. Отсутвует scheduler(функции рпределяют к какому контексту ему переходить).
*Fiber* - легковестный поток. Те же корутины, у которых точки входа/выхода обычно не возвращают значения.

В coroutine *кооперативная* многозадачность, в отличии от потоков OS (*вытесняюшая* многозадчность).

*Stackful* coroutine - держат свой стек в памяти на протяжении всего времени жизни.
*Stackless* coroutine - держим свой стек в памяти только во время работы. Работает через генерацию компилятора конечного автомата.

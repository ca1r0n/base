https://bravochos.medium.com/the-internals-of-node-js-9def593c6082

# The Basics of Node.js

NodeJS внутри имеет набор зависимостей, которые он использует для фактического выполнения вашего кода. Две наиболее важные зависимости - это V8 и libuv.

1) V8: это движок Javascript с открытым исходным кодом, созданный компанией Google. Он позволяет нам выполнять код javascript вне браузера, что мы и делаем, когда запускаем наш код javascript из терминала.
2) libuv: это проект с открытым исходным кодом на C++, который предоставляет Node.js доступ к базовой файловой системе операционной системы. Он дает нам доступ к сетевым ресурсам, а также обрабатывает некоторые аспекты параллелизма.
Короче говоря, Node.js дает нам хороший последовательный API для получения доступа к функциональности, которая в конечном итоге реализована внутри V8 в libuv, и поэтому нам не нужно беспокоиться о коде C++! :)

# Behind the scenes

![[Pasted image 20230709144820.png]]
Хорошо, давайте попробуем понять весь процесс еще раз с помощью другой диаграммы.

![[Pasted image 20230709144944.png]]
Предположим, мы написали код на Javascript и выполняем процесс. Тогда Node.js обратится к стороне javascript библиотеки node для поиска функции pbksd2, а функция под названием 'process.binding()' соединит Javascript и C++ функции.

**"Node.js поддерживается C++".

Этот process.binding - то, что служит фактическим мостом между javascript'овой стороной Node и C++. А V8 выступает в качестве посредника и позволяет значениям, которые определены внутри javascript, быть переведенными в эквивалент C++.

# Implementation of Event Loop

https://bravochos.medium.com/the-internal-of-node-js-578382b510be

![[Pasted image 20230709153646.png]]
Теперь мы перейдем к телу нашего цикла событий. Есть около 5 шагов, которые, по нашему мнению, скорее всего, должны произойти внутри цикла событий.

1. Node.js смотрит на массив "pendingTimers" и просматривает все различные функции, которые были переданы в setTimeout и setInterval.

2. Просматривает "pendingOSTasks" и "pendingOperations" и вызывает соответствующие обратные вызовы. По сути, Node.js просматривает коллекцию всех различных задач и операций, и если какая-либо из них была завершена или были вызваны новые события, Node.js выполняет соответствующие обратные вызовы.

3. Третий шаг временно приостанавливает выполнение. Во время этой паузы Node.js просто ждет новых событий и продолжит выполнение, когда произойдет определенное количество событий. Это происходит всякий раз, когда выполняется новая отложенная задача ОС, когда выполняется новая отложенная операция или когда завершается таймер.

4. Просматривает "pendingTimers" и вызывает любой setImmediate. Но в этом случае Node.js не заботится о setTimeout в вызовах функции setInterval. Он ищет только функции, которые были зарегистрированы с помощью setImmediate, и помнит, что setImmediate очень похожа на setTimeout и setInterval.

5. Наконец, обрабатывает любые события "закрытия". Это просто обработка кода очистки и уверенность в том, что у нас нет никаких оставшихся задач внутри нашей программы.

Наша программа может работать не так быстро, как могла бы, потому что она ограничена одним потоком. Однако на самом деле некоторые функции, включенные в стандартную библиотеку (или фреймворк) Node.js, на самом деле не являются однопоточными!
![[Pasted image 20230709153922.png]]

	The event loop uses a single thread but a lot of the code that we write does not actually execute inside that thread entirely

https://bravochos.medium.com/the-internals-of-node-js-b57bab6dc90

![[Pasted image 20230709154145.png]]

Внутри c++file есть ссылки на библиотеку libuv, которая предоставляет Node.js лучший доступ к операционной системе. Сторона c++ и библиотека libuv Node решают выполнять дорогостоящие вычисления полностью вне цикла событий.  
  
По умолчанию libuv создает 4 потока, как показано на диаграмме, чтобы можно было выполнять интенсивные задачи, такие как функция 'pbkdf2'.

Подведение итогов

1. Сторона c++ и библиотека libuv узла решает выполнять дорогостоящие вычисления вне цикла событий.
2. По умолчанию libuv создает 4 потока, как показано на диаграмме, чтобы иметь возможность выполнять интенсивные задачи, такие как функция 'pbkdf2'.
3. CPU позволяет нам обрабатывать более одного потока одновременно, и поэтому ядра могут обрабатывать эти два потока одновременно. Однако каждому ядру все равно приходится выполнять вдвое больший объем работы.
# References

Подробное описание
https://github.com/danielmapar/NodeJSAdvancedConcepts

